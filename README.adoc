= High
ifdef::env-github[]
:toc:

image::https://img.shields.io/clojars/v/io.dominic/high.svg[Clojars Project, link=https://clojars.org/io.dominic/high]
endif::[]

High is an inversion of control API which minimizes impact on your code.
It is an alternative to integrant, mount or component.

== Rationale

=== System as data

Systems may fail during startup, which can leave you in a state where a port is in use, but you have no handle to that partially-started system in order to close it.

[source,clojure]
----
(let [db (get-db)]
      http (start-http-server db)
      ;; What happens if make-queue-listener throws an exception?
      queue-listener (make-queue-listener)]
  â€¦)
----

This can lead to re-starting the REPL, which is a major interruption to flow.
High provides a data model for your system, and will rethrow exceptions with the partially-started components attached in order to allow automatic recovery in the REPL or during tests.

You may choose to make your system very granular.
For example, you may choose to provide each web request handler with it's dependencies directly, rather than passing them via the router.
In these cases, you will find your system quickly grows large, having your system as data reduces the effort to maintain & understand the relationships between components.

=== Boilerplate

Existing dependency injection libraries require boilerplate for defining your components.
This either comes in the form of multi-methods which must have their namespaces required for side-effects, or the creation of records in order to implement a protocol.
These extension mechanisms are used to extend existing var calls in libraries.
Instead of doing that, we can take a reference to a function (e.g. `ring.adapter.jetty/run-jetty`) and call it directly.
This means that effort to wrap an existing library is minimal, you simply have to specify what to call.
This also removes the problem of inventing new strategies for tying a keyword back to a namespace as Integrant has to, by directly using the fully qualified symbol which already includes the namespace as required. 
In addition, normal functions support doc-strings, making for easy documentation.
Finally, this use of vars means that your library is not coupled to High in any way, yet it's easy to use directly from High.

=== Transitions

Side-effects are part of a startup process.
The most common example is seeding a database.
Before other components can function (such as a health check) the migration must have run.
Existing approaches require us to either taint our component's `start` with additional side-effect code (complecting connection with migration) or to create side-effecting components which others must then depend upon.

High by default, provides a :pre and :post phase for start-up, enabling you to run setup before/after starting the component.
For example, you may need to call `datomic.api/create-database` before connecting to it, and you may want to call `my.app/seed-db` after starting it, but before passing it around.

High is also simple, it separates out running many actions on your system.
This allows you to define custom phases for components, if you need them.

=== Async

Async is a significant part of systems when doing ClojureScript applications.
Something as simple as reading data from disk or fetching the user from a remote endpoint will cause your entire system to be aware of the callback.

Interceptors have shown that async can be a layered-on concern, rather than being intrinsically present in all consumption of the result.
High provides multiple "executors" for running actions against your system, providing out of the box support for sync (no async), promesa, and manifold.
If you need an additional executor, they are fairly simple to write.

=== Obvious

Obvious connections between actions are easier to understand than obscure ones.
Use of inheritance for references or relying on implicit dependencies increases the obscurity of your API.
Component and Integrant allow you to spread out your references through the use of `using` and `prep-key`.
Instead High encourages you to make references live in the system, making it always obvious how components connect together.

== Usage

=== Defining a system configuration

You define a system configuration with data.
A system is a map from `k` to configuration.
Note the use of ``` in the example below, this is to prevent execution, you might find it easier to use EDN to define your system configuration.

[source,clojure]
----
(def system-config
  {:components
   {:db {:pre-start `(d/create-database "datomic:mem://newdb") ;; <1>
         :start `(d/connect "datomic:mem://newdb") ;; <2>
         :post-start `seed-conn} ;; <3>
    :handler {:start `(find-seed-resource (high/ref :db))} ;; <4>
    :http {:start `(yada/listener (high/ref :handler))
           :stop '((:close this)) ;; <5>
           :resolve :server} ;; <6>
    :foo {:start '(high/ref :http)}}})
----
<1> `:pre-start` will be run before `:start` for your component.  Here we use it to run the required `create-database` in datomic.
<2> `:start` is run and returns the value that other components will refer to.
<3> `:post-start` is run before passing the component to any other components.  Here, we use it to seed the connection.  Because we provided a symbol, it will be resolved and called like so `(seed-conn conn)` where `conn` is the started component.
<4> Here we use `(high/ref)` to refer to the `:db` component.  This will be provided positionally to the function.
<5> `:stop` has access to the variable `this` to refer to the started component.
<6> You can control how a component is referenced by other components.  Here the `:server` key will be passed to other components referencing it (e.g. `:foo`).

=== Async

In High, async is achieved by using alternative executors.
Out of the box support is provided for link:https://github.com/funcool/promesa[promesa] and link:https://github.com/ztellman/manifold[manifold].
Open an issue if you'd like to see support for another popular library.

Executors are specified on your system, and can either be a symbol pointing at a executor or a function. 

.Promesa Async Example
====

[source,clojure]
----
{:executor io.dominic.high.promesa/exec
 :components
 {:a {:start (promesa.core/resolved 10)}
  :b {:start (inc (high/ref :a))}}}
----

Note that `:b` does not need to be aware that `:a` returns an async value.
It will be called at the appropriate time with the resolved value.

====

.Manifold Example
====

[source,clojure]
----
(require '[manifold.deferred :as d])

{:executor io.dominic.high.manifold/exec
 :components
 {:a {:start `(d/chain 10)}
  :b {:start (inc (high/ref :a))}}}
----

====

=== Reloaded

Here's an example of using High in a reloaded workflow.

[source,clojure]
----
(ns user
  (:require [io.dominic.high.core :as high]
            [clojure.tools.namespace.repl :refer [refresh]]))

(def system-config {:a {:start 1}})
(def system nil)

(defn go []
  (alter-var-root #'system (constantly (high/start system-config))))

(defn stop []
  (alter-var-root #'system
    (fn [s] (when s (high/stop system-config s)))))

(defn reset []
  (stop)
  (refresh :after 'user/go))
----

=== ClojureScript

ClojureScript has limitations with taking code-forms as data.
This will continue to be an active research topic, but until resolved the usage is still reasonably concise.
You must use `list` to create a list-form.

.ClojureScript Usage
====

[source,clojure]
----
(ns frontend.core
  (:require [io.dominic.high.core :as high]))

(def system-config
  {:components
    {:foo {:start 200}
     :bar {:start (list inc (high/ref :foo))}}})
----

====

CAUTION: The following macro is extremely experimental, feed-back on use is welcome.

You can also bring in the `deval` macro.
This macro will convert lists of code it finds into non-evaluated lists, which can later be interpreted by High.

.Deval Usage
====

[source,clojure]
----
(ns frontend.core
  (require '[io.dominic.high.core :as high :include-macros true]))

(def system-config
  (high/deval
    {:components
      {:foo {:start 200}
       :bar {:start (inc (high/ref :foo))}}}))
----

====

CAUTION: The following tagged literal is extremely experimental, feed-back on use is welcome.

Alternatively, you can prefix code-forms with `#high/%` in order to defer their evaluation until the appropriate time.

.`#high/%` use
====

[source,clojure]
----
(ns frontend.core
  (require '[io.dominic.high.core :as high]))

(def system-config
  {:components
    {:foo {:start 200}
     :bar {:start #high/%(inc (high/ref :foo))}}})
----

====

